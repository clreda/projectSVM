--- Projet d'optimisation convexe et combinatoire : SVM -- Kamtue & Réda. ---

* Les ensembles de données utilisés dans le rapport sont disponibles dans le dossier "test".

- x: points
- y: étiquettes associées
- fail: taux d'échec sur l'ensemble de test
- conf: matrice de confusion pour l'ensemble de test
- w: solution optimale du primal
- wl: liste des w^n en fonction du nombre d'itérations de la méthode de Newton n
- a: solution optimale du dual
- al: liste des a^n en fonction du nombre d'itérations de la méthode de Newton n
- nbiter: nombre d'itérations de la méthode de Newton
- time: temps écoulé (en secondes) pour chercher la solution du dual

* On peut avoir accès au descriptif de chaque fonction avec la commande help.

* Procédures :

- Pour obtenir a (la solution optimale du dual), w (la solution optimale du primal), et la liste des a et w en fonction du nombre d'itérations de la méthode de Newton avec x (les points), y (les étiquettes) :
           [a, w, alist, wlist, confusion, failurerate] = main(C, x, y)

- Pour dessiner le plan/droite séparateur/trice :
           drawline(w, x, y) (dessine aussi les droites f(x) = 10 et f(x) = -10)
           drawplane(w, x, y)

- Pour tracer le duality gap :
           dualitygap(wlist, alist)

- Choix de C par validation croisée :
           C = choiceC(x, y)

- Générer des données :
           [x, y] = generatedata(taille, dimension)

* Description des fichiers :

- accpm.m implémente l'algorithme ACCPM
- barrier.m implémente la méthode de la barrière logarithmique
- choiceC.m permet de déterminer une bonne valeur du paramètre C par validation croisée
- coorddescent.m implémente la Coordinate Descent Method.
- crossvalidation.m implémente la méthode de leave-one-out
- drawline.m permet de tracer la frontière de classification entre les points (avec les deux premières  coordonnées)
- drawnewton.m permet de tracer la convergence de la méthode de Newton
- drawplane.m permet de tracer la frontière de classification entre les points (avec les trois premières  coordonnées)
- dualitygap.m trace ||w^n-a^n|| en fonction du nombre d'itérations n de l'algorithme de Newton
- generatedata.m génère des points de deux classes 
- main.m entraîne et teste le SVM sur un échantillon donné : calcul de la matrice de confusion 2x2
- newton.m implémente la méthode de Newton
- svmobj.m renvoie la valeur, le gradient et la hessienne de la fonction objectif avec la fonction log-barrière
